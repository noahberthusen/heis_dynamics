def Us(params):
    Meven = sp.sparse.identity(2**L)
    Modd = sp.sparse.identity(2**L)
    for i in range(L):
        if (i % 2 != 0):
            Meven = Meven @ expm(-1j * params[i] * Heis[i][(i+1)%L])
        else:
            Modd = Modd @ expm(-1j * params[i] * Heis[i][(i+1)%L])
    return (Meven, Modd)

def K_lt(r, params):
    M = sp.sparse.identity(2**L)
    for i in range(0, r-1):
        subs_params = params[i*L: (i+1)*L]
        Uevens, Uodds = Us(subs_params)
        M = M @ Uevens @ Uodds
    return M

def K_gt(r, params):
    M = sp.sparse.identity(2**L)
    for i in range(r+1, p):
        subs_params = params[i*L: (i+1)*L]
        Uevens, Uodds = Us(subs_params)
        M = M @ Uevens @ Uodds
    return M

def Chi(r, params):
    return K_gt(r, params) @ init

def S_hat(r, i, params):
    subs_params = params[r*L: (r+1)*L]
    Uevens, Uodds = Us(subs_params)
    return K_lt(r, params) @ Uevens @ Heis[i][(i+1)%L] @ Uodds 

def Ansatz(params):
    M = sp.sparse.identity(2**L)
    for i in range(p):
        subs_params = params[i*L: (i+1)*L]
        Uevens, Uodds = Us(subs_params)
        M = M @ Uevens @ Uodds
    return M

# def A(i, j, m, n, params):
#     _ = 2 * (Chi(m, params).T.conj() @ (S_hat(m, i, params).T.conj() @ O) @ Ansatz(params)).imag 
#     return _ * (Chi(n, params).T.conj() @ (S_hat(n, j, params).T.conj() @ O) @ Ansatz(params)).imag

def A(O, params):
    dim = L * p
    A = []
    ket = Ansatz(params) @ init
    Convert = lambda k: (int(np.floor(k / L)), L-1 if (k+1 % L == 0) else k % L)

    for i in range(1):
        mdepth, sitei = Convert(i)
        Smdag =  S_hat(mdepth, sitei, params).T.conj()
        Opm = Smdag @ O
        ketm = K_gt(mdepth, params) @ init
        bram = ketm.conj()

        cm = (bram @ Opm @ ket).imag
        vecaux = []

        for j in range(dim):
            ndepth, sitej = Convert(j)
            print(ndepth, sitej)
            Sndag = S_hat(ndepth, sitej, params).T.conj()
            Opn = Sndag @ O
            ketn = K_gt(ndepth, params) @ init
            bran = ketn.conj()

            cn = (bran @ Opn @ ket).imag
            vecaux.append(2 * cm * cn)
        
        print(vecaux)
        A.append(vecaux)
    return np.array(A)

def B(i, m, params):
    _ = -1 * (Ansatz(params).T.conj() @ (O @ H - H @ O) @ Ansatz(params)).imag # times hbar -- set to 1
    return _ * (Chi(m, params).T.conj() @ (S_hat(m, i, params).T.conj() @ O) @ Ansatz(params)).imag
